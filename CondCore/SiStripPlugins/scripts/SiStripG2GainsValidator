#!/usr/bin/env python3
from datetime import datetime
from pathlib import Path
import configparser as ConfigParser
import json
import logging
import optparse
import os
import sqlalchemy
import string
import subprocess
import sys
import CondCore.Utilities.conddblib as conddb

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

##############################################
def construct_conddb_import_command(db_file, frontier, tag, since):
##############################################
    """Constructs the conddb_import command."""
    return (
        f'conddb_import -c sqlite_file:{db_file} '
        f'-f {frontier} '
        f'-i {tag} -t {tag} -b {since}'
    )

##############################################
def reset_db_sync(db_file):
##############################################
    """Resets synchronization for the given SQLite file."""
    logger.info(f"Resetting synchronization for {db_file}")
    resetSynchonization(db_file)  # Assuming resetSynchonization is defined elsewhere

##############################################
def getCommandOutput(command):
##############################################
    """This function executes `command` and returns it output.
    Arguments:
    - `command`: Shell command to be invoked by this function.
    """
    child = os.popen(command)
    data = child.read()
    err = child.close()
    if err:
        print ('%s failed w/ exit code %d' % (command, err))
        sys.exit(1)  # This will stop the script immediately with the failure exit code
    print(data)
    return data

##############################################
def execute_command(command):
##############################################
    """Executes a shell command and logs the output."""
    logger.info(f"Executing command: {command}")
    getCommandOutput(command)  # Assuming getCommandOutput is defined elsewhere

##############################################
def getCerts() -> str:
##############################################
    cert_path = os.getenv('X509_USER_CERT', '')
    key_path = os.getenv('X509_USER_KEY', '')

    certs = ""
    if cert_path:
        certs += f' --cert {cert_path}'
    else:
        print("No certificate, nor proxy provided for Tier0 access")
    if key_path:
        certs += f' --key {key_path}'
    return certs

##############################################
def build_curl_command(url, proxy="", certs="", timeout=30, retries=3, user_agent="MyUserAgent"):
##############################################
    """Builds the curl command with the appropriate proxy, certs, and options."""
    cmd = f'/usr/bin/curl -k -L --user-agent "{user_agent}" '

    if proxy:
        cmd += f'--proxy {proxy} '
    else:
        cmd += f'{certs} '

    cmd += f'--connect-timeout {timeout} --retry {retries} {url}'
    return cmd

##############################################
def get_hlt_fcsr(session):
##############################################
    RunInfo = session.get_dbtype(conddb.RunInfo)
    lastRun = session.query(sqlalchemy.func.max(RunInfo.run_number)).scalar()
    fcsr = lastRun+1
    return int(fcsr)

##############################################
def fetch_data_from_url(url, proxy="", certs=""):
##############################################
    cmd = build_curl_command(url, proxy=proxy, certs=certs)

    try:
        out = subprocess.check_output(cmd, shell=True)
    except subprocess.CalledProcessError as e:
        print(f"Error executing curl command: {e}")
        return None

    if not out.strip():
        print("Received an empty response from the server.")
        return None

    try:
        response = json.loads(out)
    except json.JSONDecodeError as e:
        print(f"Failed to decode JSON: {e}")
        print(f"Raw output was: {out}")
        return None

    # Ensure the expected structure is there
    if "result" not in response or len(response["result"]) == 0:
        print("Unexpected response format or empty result.")
        return None

    return response["result"][0]  # Return the first result entry (this is where individual functions can extract specific fields)

##############################################
def getFCSR(proxy="", certs=""):
##############################################
    url = "https://cmsweb.cern.ch/t0wmadatasvc/prod/firstconditionsaferun"
    response = fetch_data_from_url(url, proxy, certs)

    if response is None:
        return None

    return int(response)  # Assuming 'response' is already an integer value in this case

##############################################
def getPromptGT(proxy="", certs=""):
##############################################
    url = "https://cmsweb.cern.ch/t0wmadatasvc/prod/reco_config"
    response = fetch_data_from_url(url, proxy, certs)

    if response is None:
        return None

    return response.get('global_tag')

##############################################
def getExpressGT(proxy="", certs=""):
##############################################
    url = "https://cmsweb.cern.ch/t0wmadatasvc/prod/express_config"
    response = fetch_data_from_url(url, proxy, certs)

    if response is None:
        return None

    return response.get('global_tag')

##############################################
def _getFCSR(proxy="", certs=""):
##############################################
    url = "https://cmsweb.cern.ch/t0wmadatasvc/prod/firstconditionsaferun"
    cmd = build_curl_command(url, proxy=proxy, certs=certs)
    out = subprocess.check_output(cmd, shell=True)
    response = json.loads(out)["result"][0]
    return int(response)

##############################################
def _getPromptGT(proxy="", certs=""):
##############################################
    url = "https://cmsweb.cern.ch/t0wmadatasvc/prod/reco_config"
    cmd = build_curl_command(url, proxy=proxy, certs=certs)
    out = subprocess.check_output(cmd, shell=True)
    response = json.loads(out)["result"][0]['global_tag']
    return response

##############################################
def _getExpressGT(proxy="", certs=""):
##############################################
    url = "https://cmsweb.cern.ch/t0wmadatasvc/prod/express_config"
    cmd = build_curl_command(url, proxy=proxy, certs=certs)
    out = subprocess.check_output(cmd, shell=True)
    response = json.loads(out)["result"][0]['global_tag']
    return response

##############################################
def resetSynchonization(db_name):
##############################################
    import sqlite3

    # Connect to the SQLite database
    conn = sqlite3.connect(db_name)

    # Create a cursor object to execute SQL commands
    cursor = conn.cursor()

    # Execute the SQL command to update the database
    cursor.execute("UPDATE TAG SET SYNCHRONIZATION='any' WHERE SYNCHRONIZATION='express';")

    # Commit the changes and close the connection
    conn.commit()
    conn.close()

##############################################
def reset_db_sync(db_file):
##############################################
    """Resets synchronization for the given SQLite file."""
    logger.info(f"Resetting synchronization for {db_file}")
    resetSynchonization(db_file)  # Assuming resetSynchonization is defined elsewhere

##############################################
def process_gt_map_elements(myGTMap, session, IOVsToValidate, options, FCSR):
##############################################
    current_directory = Path.cwd()  # Using Path for directory management

    for element in myGTMap:
        Record, Label, Tag = element

        if Record == "SiStripApvGain2Rcd":
            # Query the database
            TagIOVs = session.query(IOV.since, IOV.payload_hash, IOV.insertion_time).filter(IOV.tag_name == Tag).all()

            # Sort by 'since' value and get the last entry
            sorted_TagIOVs = sorted(TagIOVs, key=lambda x: x[0])
            lastG2Payload = sorted_TagIOVs[-1]

            logger.info(f"Last G2 Prompt payload has IOV since: {lastG2Payload[0]}, "
                        f"payload hash: {lastG2Payload[1]}, insertion time: {lastG2Payload[2]}")
            logger.info(f"Current Working Directory: {current_directory}")

            # Import the last G2 prompt payload into the database
            command = construct_conddb_import_command("toCompare.db", "frontier://FrontierProd/CMS_CONDITIONS", Tag, lastG2Payload[0])
            execute_command(command)

            # Reset synchronization
            reset_db_sync("toCompare.db")

            # Validate each IOV
            for i, validation_tag_since in enumerate(IOVsToValidate):
                # Determine the correct 'since' value
                since_value = FCSR + i if validation_tag_since < lastG2Payload[0] else validation_tag_since

                # Print warning if validation IOV is older than the express IOV
                if validation_tag_since < lastG2Payload[0]:
                    logger.warning("Validation IOV is older than the last express IOV, using FCSR as 'since'!")

                # Import validation tag
                command = construct_conddb_import_command("toCompare.db", "frontier://FrontierPrep/CMS_CONDITIONS", options.validationTag, since_value)
                execute_command(command)

                # Compare the gains
                compare_command = (
                    f'${{CMSSW_BASE}}/src/CondCore/SiStripPlugins/scripts/testCompareSiStripG2Gains.sh '
                    f'{Tag} {lastG2Payload[0]} {since_value} {current_directory}/toCompare.db'
                )
                execute_command(compare_command)

##############################################
if __name__ == "__main__":
##############################################

    parser = optparse.OptionParser(usage = 'Usage: %prog [options] <file> [<file> ...]\n')
     
    parser.add_option('-t', '--validationTag',
                      dest = 'validationTag',
                      default = "SiStripApvGainAfterAbortGap_PCL_multirun_v0_prompt",
                      help = 'validation tag',
                      )
     
    parser.add_option('-s', '--since',
                      dest = 'since',
                      default = -1,
                      help = 'sinces to copy from validation tag',
                      )

    parser.add_option('-p', '--proxy',
                      dest = 'proxy',
                      default = "",
                      help = 'proxy to use for curl requests',
                      )

    parser.add_option('-u', '--user-mode',
                      dest='user_mode',
                      action='store_true',
                      default=False,
                      help='Enable user mode with specific X509 user certificate and key')

    (options, arguments) = parser.parse_args()

    if options.user_mode:
        os.environ['X509_USER_KEY'] = os.path.expanduser('~/.globus/userkey.pem')
        os.environ['X509_USER_CERT'] = os.path.expanduser('~/.globus/usercert.pem')
        print("User mode enabled. Using X509_USER_KEY and X509_USER_CERT from ~/.globus/")

    certs = ""
    if not options.proxy:
        certs = getCerts()

    FCSR = getFCSR(proxy=options.proxy, certs=certs)
    promptGT  = getPromptGT(proxy=options.proxy, certs=certs)
    expressGT = getExpressGT(proxy=options.proxy, certs=certs)

    con = conddb.connect(url = conddb.make_url("pro"))
    session = con.session()

    HLTFCSR = get_hlt_fcsr(session)
    print ("Current next HLT run", HLTFCSR, "| curret FCSR:", FCSR ,"| Express Global Tag",expressGT,"| Prompt Global Tag",promptGT)
    IOV     = session.get_dbtype(conddb.IOV)
    TAG     = session.get_dbtype(conddb.Tag)
    GT      = session.get_dbtype(conddb.GlobalTag)
    GTMAP   = session.get_dbtype(conddb.GlobalTagMap)
    RUNINFO = session.get_dbtype(conddb.RunInfo)

    myGTMap = session.query(GTMAP.record, GTMAP.label, GTMAP.tag_name).\
        filter(GTMAP.global_tag_name == str(expressGT)).\
        order_by(GTMAP.record, GTMAP.label).\
        all()

    # Check if the query result is empty
    if not myGTMap:
        print("No records found in the GTMap.")
        sys.exit(1)

    ## connect to prep DB and get the list of IOVs to look at
    con2 = conddb.connect(url = conddb.make_url("dev"))
    session2 = con2.session()
    validationTagIOVs = session2.query(IOV.since,IOV.payload_hash,IOV.insertion_time).filter(IOV.tag_name == options.validationTag).all()

    ### fill the list of IOVs to be validated
    IOVsToValidate=[]
    if(options.since==-1):
        IOVsToValidate.append(validationTagIOVs[-1][0])
        print("Changing the default validation tag since to:",IOVsToValidate[0])
        
    else:
        for entry in validationTagIOVs:
            if(options.since!=1 and int(entry[0])>=int(options.since)):
                print("Appending to the validation list:",entry[0],entry[1],entry[2])
                IOVsToValidate.append(entry[0])

    process_gt_map_elements(myGTMap, session, IOVsToValidate, options, HLTFCSR)
